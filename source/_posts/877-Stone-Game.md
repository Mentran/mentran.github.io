title: 877. Stone Game
author: Mentran
tags:
  - dp
  - code
  - python
categories:
  - leetcode
date: 2019-08-07 10:44:00
---
### 题目

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

 

示例：
```
输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
```

提示：

* 2 <= piles.length <= 500
* piles.length 是偶数。
* 1 <= piles[i] <= 500
* sum(piles) 是奇数。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---


### 思路

1. 首先可以看出是一道DP的题目
2. 需要找到一个状态转移的式子
3. 可以分析出第`n`个的最优解只有两种选择：
>* 一是选择第一个石头，那么余下的`n-1`个石头的最优解由另一个人取得；
>* 二是选择最后一个石头，那么前`n-1`个石头的最优解由另一个人取得；
>* 那么第`n`个的最优解就是 `dp[n] = max(piles[0] - dp[1->n], piles[n] - dp[0->n-1])`
4. 从起始状态开始分析，模拟状态转移

### 模拟求解
模拟`piles = [3, 2, 10, 4]`进行求解每一步的结果：
1. 选1个石头时的最优解就是选当前这个石头，即
```python
dp[0] = piles[0] = 3
dp[1] = piles[1] = 2
dp[2] = piles[2] = 10
dp[3] = piles[3] = 4
```
2. 选2个石头时的最优解，就需要考虑比较当前石头和下一个石头的大小，即
```python
dp[0] = max(piles[0] - piles[1], piles[1] - piles[0]) = max(1, -1) = 1
dp[1] = max(piles[1] - piles[2], piles[2] - piles[1]) = max(-8, 8) = 8
dp[2] = max(piles[2] - piles[3], piles[3] - piles[2]) = max(6, -6) = 6
```
3. 选3个石头时，需要考虑当你选了某个石头，那么你的对手就能选余下石头的最优解，即
>* 当第一步选第一个位置的 3 时，那么对手将选2,3两个位置的最优解，即上一步的dp[1]，那么结果为 3 - 8 = -5;
>* 当第一步选最后一个位置 10 时，那么对手将选1,2两个位置的最优解，即上一步的dp[0]，那么结果为 10 - 1 = 9

	所以，选3个石头的最优解标识为
```python
dp[0] = max(piles[0] - dp[1], piles[2] - dp[0]) = max(3-8, 10-1) = 9
dp[1] = max(piles[1] - dp[2], piles[3] - dp[1]) = max(2-6, 4-8) = -4
```
4. 选4个石头时，还是两种选法，比较选了第一个和选了最后一个的最大值：
```python
dp[0] = max(piles[0] - dp[1], piles[3] - dp[0]) = max(3-(-4), 4-9) = 7
```
得到最终赢得石头数是 `7`

### 代码
```python
def stoneGame(piles: list):
    n = len(piles)
    dp = list(piles)

    for i in range(1, n):
        for j in range(0, n - i):
            dp[j] = max(piles[j] - dp[j + 1], piles[i + j] - dp[j])

    return dp[0] > 0
```