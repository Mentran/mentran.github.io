<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow-Java]]></title>
    <url>%2F2019%2F08%2F21%2FTensorflow-Java%2F</url>
    <content type="text"><![CDATA[Tensorflow模型保存和读取1. pb模型保存12345# save for javafrozen_graph_def = tf.graph_util.convert_variables_to_constants(sess, sess.graph_def, output_node_names=["prob", "accuracy"])# save as.pb filetf.train.write_graph(frozen_graph_def, 'path', "model_name.pb", as_text=False)tf.train.write_graph(frozen_graph_def, 'path', "model_name.txt", as_text=True) pb 文件已经固化了网络模型结构，因此可恢复训练模型的结构和所有参数，但是必须知道原网络模型的输入和输出的节点名称 其中output_node_names中的名称必须与模型中的节点名称一致，例如 1(self.prob = tf.nn.softmax(self.outputs, name="prob")) 注意节点名称，应包含name_scope 和 variable_scope命名空间，并用“/”隔开，如”InceptionV3/Logits/SpatialSqueeze” 保存模型可以选择pb格式或者txt格式 2. pb模型读取123456789101112131415161718192021222324with tf.Graph().as_default(): output_graph_def = tf.GraphDef() with open(pb_path, "rb") as f: output_graph_def.ParseFromString(f.read()) tf.import_graph_def(output_graph_def, name="") with tf.Session() as sess: sess.run(tf.global_variables_initializer()) # 定义输入的张量名称,对应网络结构的输入张量 # input:0作为输入图像,keep_prob:0作为dropout的参数,测试时值为1,is_training:0训练参数 input_image_tensor = sess.graph.get_tensor_by_name("input:0") input_keep_prob_tensor = sess.graph.get_tensor_by_name("keep_prob:0") input_is_training_tensor = sess.graph.get_tensor_by_name("is_training:0") # 定义输出的张量名称 output_tensor_name = sess.graph.get_tensor_by_name("InceptionV3/Logits/SpatialSqueeze:0") # 读取测试图片 im=read_image(image_path,resize_height,resize_width,normalization=True) im=im[np.newaxis,:] # 测试读出来的模型是否正确，注意这里传入的是输出和输入节点的tensor的名字，不是操作节点的名字 # out=sess.run("InceptionV3/Logits/SpatialSqueeze:0", feed_dict=&#123;'input:0': im,'keep_prob:0':1.0,'is_training:0':False&#125;) out=sess.run(output_tensor_name, feed_dict=&#123;input_image_tensor: im, input_keep_prob_tensor:1.0, input_is_training_tensor:False&#125;) 模型中节点的名称可以通过保存的 text 模型文件中进行查看和修改 3. ckpt模型的保存123456789101112import tensorflow as tf# 声明两个变量v1 = tf.Variable(tf.random_normal([1, 2]), name="v1")v2 = tf.Variable(tf.random_normal([2, 3]), name="v2")init_op = tf.global_variables_initializer() # 初始化全部变量saver = tf.train.Saver() # 声明tf.train.Saver类用于保存模型with tf.Session() as sess: sess.run(init_op) print("v1:", sess.run(v1)) # 打印v1、v2的值一会读取之后对比 print("v2:", sess.run(v2)) saver_path = saver.save(sess, "save/model.ckpt") # 将模型保存到save/model.ckpt文件 print("Model saved in file:", saver_path) 保存后有4个文件： checkpoint 是检查点文件，文件保存了一个目录下所有的模型文件列表 model.ckpt.meta 文件保存了TensorFlow计算图的结构，可以理解为神经网络的网络结构，该文件可以被 tf.train.import_meta_graph 加载到当前默认的图来使用。 ckpt.data 保存模型中每个变量的取值 ckpt.index 索引文件 4. ckpt模型转换成pb模型文件 通过传入 CKPT 模型的路径得到模型的图和变量数据 通过 import_meta_graph 导入模型中的图 通过 saver.restore 从模型中恢复图中各个变量的数据 通过 graph_util.convert_variables_to_constants 将模型持久化 1234567891011121314151617181920212223def freeze_graph(input_checkpoint, output_graph):''':param input_checkpoint::param output_graph: PB模型保存路径:return:'''# checkpoint = tf.train.get_checkpoint_state(model_folder) #检查目录下ckpt文件状态是否可用# input_checkpoint = checkpoint.model_checkpoint_path #得ckpt文件路径# 指定输出的节点名称,该节点名称必须是原模型中存在的节点output_node_names = "InceptionV3/Logits/SpatialSqueeze"saver = tf.train.import_meta_graph(input_checkpoint + '.meta', clear_devices=True)with tf.Session() as sess: saver.restore(sess, input_checkpoint) #恢复图并得到数据 output_graph_def = graph_util.convert_variables_to_constants( # 模型持久化，将变量值固定 sess=sess, input_graph_def=sess.graph_def,# 等于:sess.graph_def output_node_names=output_node_names.split(","))# 如果有多个输出节点，以逗号隔开 with tf.gfile.GFile(output_graph, "wb") as f: #保存模型 f.write(output_graph_def.SerializeToString()) #序列化输出 print("%d ops in the final graph." % len(output_graph_def.node)) #得到当前图有几个操作节点 5. pb模型和txt模型的转换123456789101112131415161718192021222324252627import tensorflow as tffrom google.protobuf import text_formatfrom tensorflow.python.platform import gfiledef convert_pb_to_pbtxt(filename): with gfile.FastGFile(filename, 'rb') as f: graph_def = tf.GraphDef() graph_def.ParseFromString(f.read()) tf.import_graph_def(graph_def, name='') tf.train.write_graph(graph_def, './', 'protobuf.pbtxt', as_text=True) returndef convert_pbtxt_to_pb(filename): """Returns a `tf.GraphDef` proto representing the data in the given pbtxt file. Args: filename: The name of a file containing a GraphDef pbtxt (text-formatted `tf.GraphDef` protocol buffer data). """ with tf.gfile.FastGFile(filename, 'r') as f: graph_def = tf.GraphDef() file_content = f.read() # Merges the human-readable string in `file_content` into `graph_def`. text_format.Merge(file_content, graph_def) tf.train.write_graph(graph_def, './', 'protobuf.pb', as_text=False) return Java 调用 Tensorflow 模型1. 通过 Maven 引用依赖文件12345&lt;dependency&gt; &lt;groupId&gt;org.tensorflow&lt;/groupId&gt; &lt;artifactId&gt;tensorflow&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt;&lt;/dependency&gt; 2. 通过 Java 原生接口 (JNI) 与 JDK 配合使用 下载 libtensorflow.jar 包 下载 tensorflow_jni.dll 文件 下载地址：https://www.tensorflow.org/install/lang_java#download 3. 调用 pb 模型1234567891011121314151617181920try (Graph graph = new Graph()) &#123; //导入图 byte[] graphBytes = IOUtils.toByteArray(new FileInputStream(model_path)); graph.importGraphDef(graphBytes); //根据图建立Session try (Session session = new Session(graph)) &#123; //相当于TensorFlow Python中的sess.run(["out_name1", "out_name2"], feed_dict = &#123;"input_name": 10.0&#125;) // 注意这里的名称必须与模型中的节点名称一致 // 可通过feed和fetch输入输出多个结果 List&lt;Tensor&lt;?&gt;&gt; tensorList = session.runner() .feed("input_name", Tensor.create(10.0f)) .fetch("out_name1") .fetch("out_name2") .run(); for (Tensor t : tensorList) &#123; System.out.println(t.floatValue()); &#125; &#125;&#125; 可通过保存的 txt 模型查看节点的名称 可修改保存的 txt 模型中的参数值，并将 txt 模型再转换成 pb 模型进行使用 示例：修改dropout值在训练tensorflow模型时，经常需要设置 dropout；但是在测试时需要将dropout值固定；有时会忘记把dropout设置为placeholder进行传值，就可以通过修改保存的 pb 模型中的dropout值来达到目的（这样就不需要重新训练模型和修改模型结构） 将 pb 模型转换成 txt 模型 在 txt 模型中查询 dropout/keep_prob 将其中的 float_val 改为 1.0 即可 再将 txt 模型转回 pb 模型]]></content>
      <categories>
        <category>tensorflow</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>pb</tag>
        <tag>model</tag>
        <tag>java</tag>
        <tag>tf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72. Edit Distance]]></title>
    <url>%2F2019%2F08%2F07%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[题目给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符 示例 1: 123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例 2: 12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/edit-distance著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 DP 问题 考虑状态变化 dp[i][j] 有3种变化 dp[i-1][j-1] : word1[i] 修改为 word2[j]，注意当word1[i]==word2[j]时，编辑距离不变，否则编辑距离+1 dp[i-1][j] : word1 插入字符 或 word2[j] 删除字符，编辑距离+1 dp[i][j-1] : word1 删除字符 或 word2[j] 插入字符，编辑距离+1 状态转移方程 1dp[i][j] = min(dp[i-1][j-1] + (word1[i]!=word2[j]), dp[i-1][j] + 1, dp[i][j-1] + 1) 考虑初始状态 代码1234567891011121314def minDistance(word1: str, word2: str) -&gt; int: l1, l2 = len(word1), len(word2) dp = [[0] * (l2 + 1) for _ in range(l1 + 1)] for i in range(l1 + 1): dp[i][0] = i for j in range(l2 + 1): dp[0][j] = j for i in range(1, l1 + 1): for j in range(1, l2 + 1): dp[i][j] = min(dp[i - 1][j - 1] + (word1[i - 1] != word2[j - 1]), dp[i - 1][j] + 1, dp[i][j - 1] + 1) return dp[l1][l2] 空间优化观察状态转移方程可以发现，dp[i][j] 的值只跟比(i, j)小的值有关，即可重复使用上一步的结果 可增加1行保存上一层的结果 可增加1个变量记录每次被更改的 dp[i-1][j-1]12345678910111213141516def minDistance(word1: str, word2: str) -&gt; int: l1, l2 = len(word1), len(word2) dp = [0] * (l2 + 1) for j in range(l2 + 1): dp[j] = j for i in range(1, l1 + 1): old_dp = dp[0] dp[0] = i for j in range(1, l2 + 1): tmp = dp[j] dp[j] = min(old_dp + (word1[i - 1] != word2[j - 1]), dp[j] + 1, dp[j - 1] + 1) old_dp = tmp return dp[l2]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>edit distance</tag>
        <tag>python</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[877. Stone Game]]></title>
    <url>%2F2019%2F08%2F07%2F877-Stone-Game%2F</url>
    <content type="text"><![CDATA[题目亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 12345678输入：[5,3,4,5]输出：true解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500 piles.length 是偶数。 1 &lt;= piles[i] &lt;= 500 sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 首先可以看出是一道DP的题目 需要找到一个状态转移的式子 可以分析出第n个的最优解只有两种选择： 一是选择第一个石头，那么余下的n-1个石头的最优解由另一个人取得； 二是选择最后一个石头，那么前n-1个石头的最优解由另一个人取得； 那么第n个的最优解就是 dp[n] = max(piles[0] - dp[1-&gt;n], piles[n] - dp[0-&gt;n-1]) 从起始状态开始分析，模拟状态转移 模拟求解模拟piles = [3, 2, 10, 4]进行求解每一步的结果： 选1个石头时的最优解就是选当前这个石头，即 1234dp[0] = piles[0] = 3dp[1] = piles[1] = 2dp[2] = piles[2] = 10dp[3] = piles[3] = 4 选2个石头时的最优解，就需要考虑比较当前石头和下一个石头的大小，即 123dp[0] = max(piles[0] - piles[1], piles[1] - piles[0]) = max(1, -1) = 1dp[1] = max(piles[1] - piles[2], piles[2] - piles[1]) = max(-8, 8) = 8dp[2] = max(piles[2] - piles[3], piles[3] - piles[2]) = max(6, -6) = 6 选3个石头时，需要考虑当你选了某个石头，那么你的对手就能选余下石头的最优解，即 当第一步选第一个位置的 3 时，那么对手将选2,3两个位置的最优解，即上一步的dp[1]，那么结果为 3 - 8 = -5; 当第一步选最后一个位置 10 时，那么对手将选1,2两个位置的最优解，即上一步的dp[0]，那么结果为 10 - 1 = 9 所以，选3个石头的最优解标识为 12dp[0] = max(piles[0] - dp[1], piles[2] - dp[0]) = max(3-8, 10-1) = 9dp[1] = max(piles[1] - dp[2], piles[3] - dp[1]) = max(2-6, 4-8) = -4 选4个石头时，还是两种选法，比较选了第一个和选了最后一个的最大值： 1dp[0] = max(piles[0] - dp[1], piles[3] - dp[0]) = max(3-(-4), 4-9) = 7 得到最终赢得石头数是 7 代码123456789def stoneGame(piles: list): n = len(piles) dp = list(piles) for i in range(1, n): for j in range(0, n - i): dp[j] = max(piles[j] - dp[j + 1], piles[i + j] - dp[j]) return dp[0] &gt; 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>python</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh]]></title>
    <url>%2F2019%2F07%2F31%2Fzsh%2F</url>
    <content type="text"><![CDATA[zsh 环境准备 查看当前 shell 环境 12echo $SHELL #查看当前shell环境cat /etc/shells # 查看是否已安装zsh 安装zsh 12sudo apt-get install zsh # ubuntubrew install zsh # mac 切换shell环境 1chsh -s /usr/bin/zsh 下载安装 oh-my-zsh 12345# wgetsh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"# curlsh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 配置 zsh 主题和插件 下载 命令高亮 插件 zsh-syntax-highlighting 到 zsh 插件库中 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting 下载 自动提示补全 插件 zsh-autosuggestions 到 zsh 插件库中 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改主题：打开~/.zshrc 文件，将 ZSH_THEME 字段改为 1ZSH_THEME="ys" 使用插件：打开~/.zshrc 文件，将 plugins 字段改为 1plugins=(git z zsh-syntax-highlighting zsh-autosuggestions) 使修改生效 1source ~/.zshrc]]></content>
      <tags>
        <tag>配置</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 操作介绍]]></title>
    <url>%2F2019%2F07%2F30%2FGit-%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Git简介Git是一个分布式版本控制系统，每个终端都是一个完整的版本库，保留了所有数据信息和修改记录。 用户配置全局配置 设置以后该计算机上所有的git仓库都使用该用户12git config --global user.name "Name"git config --global user.email "Email" 单独配置 通过修改每个项目的.git/config文件进行设置 1234# 增加user配置[user] name = username email = email@address.com 在项目中重新指定用户 12git config user.name "New user"git config user.email "New email" 工作区，暂存区，仓库 Working Tree 当前的工作区域 Index/Stage 暂存区域，和git stash命令暂存的地方不一样。使用git add xx，就可以将xx添加近Stage里面 Repository 提交的历史，即使用git commit提交后的结果 常用命令123456cd new_flodergit init # 在 new_floder 下创建本地仓库，当前目录即为 工作区touch new_file # 创建新文件git add . # 将该目录下文件加入到 暂存区git status # 查看修改信息git commit -m "message" # 将暂存区的内容提交到 当前分支 Git管理的是文件的修改，需要将所有改变的文件通过 git add 加入到暂存区。git commit只负责提交暂存区中的内容到当前分支上。 reset三种模式reset就是让 HEAD 指针指向目标节点。 git reset –hard: 重置HEAD位置，并把工作区，暂存区和仓库内容都完全重置到Reset节点的内容 git reset –soft: 重置HEAD位置，保留工作区和暂存区的内容，只让仓库内容与Reset节点一致。原节点与Reset不一致的内容都放到暂存区中。 git reset –mixed(默认): 重置HEAD位置，只保留工作区的内容，将暂存区和仓库内容更改与Reset节点保持一致。原节点与Reset节点不一致的内容都放到工作区。 撤销12345678git status # 查看当前暂存区的内容git checkout -- file # 将工作区中的内容修改进行撤销# 如果暂存区有内容则使用暂存区内容# 否则使用版本库中的内容git reset --hard HEAD^ # 将所有内容回退到上一个版本git reset --hard commit_id # 将所有内容回退到指定版本 远程仓库提交 首先通过Github建立一个远程仓库的repository git remote add origin git@github.com:xxx/xxx.git git push origin master # 将本地的(master)内容提交到远程库上 克隆12git clone git@github.com/xxx/xxx.git # 默认克隆master分支的内容git clone -b new_branch git@github.com/xxx/xxx.git # 克隆new_branch 分支管理分支就是在当前记录下通过构建一个新的指针来创建一个支线。 创建新的分支并切换 12git branch new_branchgit checkout new_branch 1git checkout -b new_branch 12git branch # 查看分支情况git branch -d new_branch # 删除分支 merge切换回master分支，并将new_branch分支进行合并 12git checkout mastergit merge new_branch stash保存现场保存当前的工作区环境，处理其他branch事务；完成后再恢复现场。 1234git stash # 保存现场... # 其他事务git stash list # 查看现场git stash pop # 恢复最近的现场]]></content>
      <tags>
        <tag>git</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2018%2F04%2F11%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown SyntaxBasic标题# 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题列表* + - 都可以表示无序列表 1. 表示有序列表 * [ ] 待办事项 * [x] 已办事项引用&gt; text &gt; &gt;&gt; text &gt; &gt; text 强调*text* # 斜体 **text** # 加粗 ~~text~~ # 删除分割线*** ---图片与链接[链接文本](link &quot;Title&quot;) ![alt text](/path/to/img.jpg &quot;Title&quot;)代码1. tab自动建立一个代码区块 2. `代码` 可用于行内，嵌入到文字中 3. 用 3个`+language 来写大块代码表格|标题|标题|标题| |:-|:-:|-:| |居左|居中|居右| 注：第二行用于分割表头和内容，每行两边都用|或者都不用 标题 标题 标题 居左 居中 居右 Next 主题内建插件引用块123&#123;% centerquote %&#125;Everyone you will ever meet knows something you don&apos;t.&#123;% endcenterquote %&#125; Everyone you will ever meet knows something you don’t. 123&#123;% blockquote 作者, 来源 %&#125;Mind.&#123;% endblockquote %&#125; Mind. 作者来源 123&#123;% blockquote Author http://linkaddress link content %&#125;Content&#123;% endblockquote %&#125; Content Authorlink content 其他嵌入12345678&#123;% iframe url [width] [height] %&#125;&#123;% youtube video_id %&#125;&#123;% fullimage /image_path, alt, title %&#125;# Bootstrap class_name&#123;% note class_name %&#125; Content &#123;% endnote %&#125; Bootstrap Primary]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deploy Hexo on Github]]></title>
    <url>%2F2018%2F04%2F10%2FDeploy-Hexo-on-Github%2F</url>
    <content type="text"><![CDATA[Deploy Hexo on Githubgithttps://git-scm.com/download/ Node.jshttp://nodejs.org/download/ Hexoinstall Hexo1npm install -g hexo init and start server1234hexo init # create a new Hexo foldernpm install # install dependencyhexo g # generate staic fileshexo s # start server set git infomation1234567npm install hexo-deployer-git --savevi _config.yml-----------_config.yml-----------------deploy: type: git repo: git@github.com:yourname.github.io.git branch: master create new post1hexo new [layout] &lt;title&gt; deploy your blog to git12hexo cleanhexo d # deploy Manager source code on gitcreate a new branch to save code12git branch hexo # new branch 'hexo'git checkout hexo # checkout to 'hexo' add remote origin and push12345git initgit add .git commit -m "message" # commitgit remote add origin git@github.comgit push origin hexo # push local hexo to remote branch hexo]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
