<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[877. Stone Game]]></title>
    <url>%2F2019%2F08%2F07%2F877-Stone-Game%2F</url>
    <content type="text"><![CDATA[题目亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 12345678输入：[5,3,4,5]输出：true解释：亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。假设他取了前 5 颗，这一行就变成了 [3,4,5] 。如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500 piles.length 是偶数。 1 &lt;= piles[i] &lt;= 500 sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 首先可以看出是一道DP的题目 需要找到一个状态转移的式子 可以分析出第n个的最优解只有两种选择： 一是选择第一个石头，那么余下的n-1个石头的最优解由另一个人取得； 二是选择最后一个石头，那么前n-1个石头的最优解由另一个人取得； 那么第n个的最优解就是 dp[n] = max(piles[0] - dp[1-&gt;n], piles[n] - dp[0-&gt;n-1]) 从起始状态开始分析，模拟状态转移 模拟求解模拟piles = [3, 2, 10, 4]进行求解每一步的结果： 选1个石头时的最优解就是选当前这个石头，即 1234dp[0] = piles[0] = 3dp[1] = piles[1] = 2dp[2] = piles[2] = 10dp[3] = piles[3] = 4 选2个石头时的最优解，就需要考虑比较当前石头和下一个石头的大小，即 123dp[0] = max(piles[0] - piles[1], piles[1] - piles[0]) = max(1, -1) = 1dp[1] = max(piles[1] - piles[2], piles[2] - piles[1]) = max(-8, 8) = 8dp[2] = max(piles[2] - piles[3], piles[3] - piles[2]) = max(6, -6) = 6 选3个石头时，需要考虑当你选了某个石头，那么你的对手就能选余下石头的最优解，即 当第一步选第一个位置的 3 时，那么对手将选2,3两个位置的最优解，即上一步的dp[1]，那么结果为 3 - 8 = -5; 当第一步选最后一个位置 10 时，那么对手将选1,2两个位置的最优解，即上一步的dp[0]，那么结果为 10 - 1 = 9 所以，选3个石头的最优解标识为 12dp[0] = max(piles[0] - dp[1], piles[2] - dp[0]) = max(3-8, 10-1) = 9dp[1] = max(piles[1] - dp[2], piles[3] - dp[1]) = max(2-6, 4-8) = -4 选4个石头时，还是两种选法，比较选了第一个和选了最后一个的最大值： 1dp[0] = max(piles[0] - dp[1], piles[3] - dp[0]) = max(3-(-4), 4-9) = 7 得到最终赢得石头数是 7 代码123456789def stoneGame(piles: list): n = len(piles) dp = list(piles) for i in range(1, n): for j in range(0, n - i): dp[j] = max(piles[j] - dp[j + 1], piles[i + j] - dp[j]) return dp[0] &gt; 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>code</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh]]></title>
    <url>%2F2019%2F07%2F31%2Fzsh%2F</url>
    <content type="text"><![CDATA[zsh 环境准备 查看当前 shell 环境 12echo $SHELL #查看当前shell环境cat /etc/shells # 查看是否已安装zsh 安装zsh 12sudo apt-get install zsh # ubuntubrew install zsh # mac 切换shell环境 1chsh -s /usr/bin/zsh 下载安装 oh-my-zsh 12345# wgetsh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"# curlsh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 配置 zsh 主题和插件 下载 命令高亮 插件 zsh-syntax-highlighting 到 zsh 插件库中 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting 下载 自动提示补全 插件 zsh-autosuggestions 到 zsh 插件库中 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 修改主题：打开~/.zshrc 文件，将 ZSH_THEME 字段改为 1ZSH_THEME="ys" 使用插件：打开~/.zshrc 文件，将 plugins 字段改为 1plugins=(git z zsh-syntax-highlighting zsh-autosuggestions) 使修改生效 1source ~/.zshrc]]></content>
      <tags>
        <tag>配置</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 操作介绍]]></title>
    <url>%2F2019%2F07%2F30%2FGit-%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Git简介Git是一个分布式版本控制系统，每个终端都是一个完整的版本库，保留了所有数据信息和修改记录。 用户配置全局配置 设置以后该计算机上所有的git仓库都使用该用户12git config --global user.name "Name"git config --global user.email "Email" 单独配置 通过修改每个项目的.git/config文件进行设置 1234# 增加user配置[user] name = username email = email@address.com 在项目中重新指定用户 12git config user.name "New user"git config user.email "New email" 工作区，暂存区，仓库 Working Tree 当前的工作区域 Index/Stage 暂存区域，和git stash命令暂存的地方不一样。使用git add xx，就可以将xx添加近Stage里面 Repository 提交的历史，即使用git commit提交后的结果 常用命令123456cd new_flodergit init # 在 new_floder 下创建本地仓库，当前目录即为 工作区touch new_file # 创建新文件git add . # 将该目录下文件加入到 暂存区git status # 查看修改信息git commit -m "message" # 将暂存区的内容提交到 当前分支 Git管理的是文件的修改，需要将所有改变的文件通过 git add 加入到暂存区。git commit只负责提交暂存区中的内容到当前分支上。 reset三种模式reset就是让 HEAD 指针指向目标节点。 git reset –hard: 重置HEAD位置，并把工作区，暂存区和仓库内容都完全重置到Reset节点的内容 git reset –soft: 重置HEAD位置，保留工作区和暂存区的内容，只让仓库内容与Reset节点一致。原节点与Reset不一致的内容都放到暂存区中。 git reset –mixed(默认): 重置HEAD位置，只保留工作区的内容，将暂存区和仓库内容更改与Reset节点保持一致。原节点与Reset节点不一致的内容都放到工作区。 撤销12345678git status # 查看当前暂存区的内容git checkout -- file # 将工作区中的内容修改进行撤销# 如果暂存区有内容则使用暂存区内容# 否则使用版本库中的内容git reset --hard HEAD^ # 将所有内容回退到上一个版本git reset --hard commit_id # 将所有内容回退到指定版本 远程仓库提交 首先通过Github建立一个远程仓库的repository git remote add origin git@github.com:xxx/xxx.git git push origin master # 将本地的(master)内容提交到远程库上 克隆12git clone git@github.com/xxx/xxx.git # 默认克隆master分支的内容git clone -b new_branch git@github.com/xxx/xxx.git # 克隆new_branch 分支管理分支就是在当前记录下通过构建一个新的指针来创建一个支线。 创建新的分支并切换 12git branch new_branchgit checkout new_branch 1git checkout -b new_branch 12git branch # 查看分支情况git branch -d new_branch # 删除分支 merge切换回master分支，并将new_branch分支进行合并 12git checkout mastergit merge new_branch stash保存现场保存当前的工作区环境，处理其他branch事务；完成后再恢复现场。 1234git stash # 保存现场... # 其他事务git stash list # 查看现场git stash pop # 恢复最近的现场]]></content>
      <tags>
        <tag>git</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Syntax]]></title>
    <url>%2F2018%2F04%2F11%2FMarkdown-Syntax%2F</url>
    <content type="text"><![CDATA[Markdown SyntaxBasic标题# 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ####### 六级标题列表* + - 都可以表示无序列表 1. 表示有序列表 * [ ] 待办事项 * [x] 已办事项引用&gt; text &gt; &gt;&gt; text &gt; &gt; text 强调*text* # 斜体 **text** # 加粗 ~~text~~ # 删除分割线*** ---图片与链接[链接文本](link &quot;Title&quot;) ![alt text](/path/to/img.jpg &quot;Title&quot;)代码1. tab自动建立一个代码区块 2. `代码` 可用于行内，嵌入到文字中 3. 用 3个`+language 来写大块代码表格|标题|标题|标题| |:-|:-:|-:| |居左|居中|居右| 注：第二行用于分割表头和内容，每行两边都用|或者都不用 标题 标题 标题 居左 居中 居右 Next 主题内建插件引用块123&#123;% centerquote %&#125;Everyone you will ever meet knows something you don&apos;t.&#123;% endcenterquote %&#125; Everyone you will ever meet knows something you don’t. 123&#123;% blockquote 作者, 来源 %&#125;Mind.&#123;% endblockquote %&#125; Mind. 作者来源 123&#123;% blockquote Author http://linkaddress link content %&#125;Content&#123;% endblockquote %&#125; Content Authorlink content 其他嵌入12345678&#123;% iframe url [width] [height] %&#125;&#123;% youtube video_id %&#125;&#123;% fullimage /image_path, alt, title %&#125;# Bootstrap class_name&#123;% note class_name %&#125; Content &#123;% endnote %&#125; Bootstrap Primary]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deploy Hexo on Github]]></title>
    <url>%2F2018%2F04%2F10%2FDeploy-Hexo-on-Github%2F</url>
    <content type="text"><![CDATA[Deploy Hexo on Githubgithttps://git-scm.com/download/ Node.jshttp://nodejs.org/download/ Hexoinstall Hexo1npm install -g hexo init and start server1234hexo init # create a new Hexo foldernpm install # install dependencyhexo g # generate staic fileshexo s # start server set git infomation1234567npm install hexo-deployer-git --savevi _config.yml-----------_config.yml-----------------deploy: type: git repo: git@github.com:yourname.github.io.git branch: master create new post1hexo new [layout] &lt;title&gt; deploy your blog to git12hexo cleanhexo d # deploy Manager source code on gitcreate a new branch to save code12git branch hexo # new branch 'hexo'git checkout hexo # checkout to 'hexo' add remote origin and push12345git initgit add .git commit -m "message" # commitgit remote add origin git@github.comgit push origin hexo # push local hexo to remote branch hexo]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
